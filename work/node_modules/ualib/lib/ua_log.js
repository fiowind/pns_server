/*!
 * Log.js
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var fs = require('fs');
var fmt = require('util').format;
var EventEmitter = require('events').EventEmitter;

/**
 * Initialize a `Loggeer` with the given log `level` defaulting
 * to __DEBUG__ and `stream` defaulting to _stdout_.
 *
 * @param {Number} level
 * @param {Object} stream
 * @api public
 */

/*
var Log = exports = module.exports = function Log(level, stream){
  if ('string' == typeof level) level = exports[level.toUpperCase()];
  this.level = level || exports.DEBUG;
  this.stream = stream || process.stdout;
  if (this.stream.readable) this.read();
};
*/

var Log = exports = module.exports = function Log(level, processName){
  if ('string' == typeof level) level = exports[level.toUpperCase()];
  this.level = level || exports.DEBUG;
  this.processName = processName;
  this.logpath = process.env.HOME + '/logs/' + processName;
  this.logfile = this.getLogFile();
  this.day = -1;
  this.stream;
};


/**
 * System is unusable.
 *
 * @type Number
 */

exports.EMG = 0;

/**
 * Action must be taken immediately.
 *
 * @type Number
 */

exports.ALT = 1;

/**
 * Critical condition.
 *
 * @type Number
 */

exports.CRI = 2;

/**
 * Error condition.
 *
 * @type Number
 */

exports.ERR = 3;

/**
 * Warning condition.
 *
 * @type Number
 */

exports.WRN = 4;

/**
 * Normal but significant condition.
 *
 * @type Number
 */

exports.NOT = 5;

/**
 * Purely informational message.
 *
 * @type Number
 */

exports.INF = 6;

/**
 * Application debug messages.
 *
 * @type Number
 */

exports.DBG = 7;

/**
 * prototype.
 */

Log.prototype = {

  /**
   * Start emitting "line" events.
   *
   * @api public
   */

  read: function(){
    var buf = ''
      , self = this
      , stream = this.stream;

    stream.setEncoding('utf8');
    stream.on('data', function(chunk){
      buf += chunk;
      if ('\n' != buf[buf.length - 1]) return;
      buf.split('\n').map(function(line){
        if (!line.length) return;
        try {
          var captures = line.match(/^\[([^\]]+)\] (\w+) (.*)/);
          var obj = {
              date: new Date(captures[1])
            , level: exports[captures[2]]
            , levelString: captures[2]
            , msg: captures[3]
          };
          self.emit('line', obj);
        } catch (err) {
          // Ignore
        }
      });
      buf = '';
    });

    stream.on('end', function(){
      self.emit('end');
    });
  },

  getLogTime: function () {
  	  var d = new Date();
  	  var hh = d.getHours().toString();
  	  var mm = d.getMinutes().toString();
  	  var ss = d.getSeconds().toString();

  	  var pad = function (val,len) {
		  val = String(val);
		  len = len || 2;
		  while (val.length < len) val = "0" + val;
		  return val;
	  };
  	  return pad(hh) + ':' + pad(mm) + ':' + pad(ss) + ' ';
  },

  getLogFile: function () {
	var d = new Date();
	var yyyy = d.getFullYear().toString();
	var mm = (d.getMonth() + 1).toString();
	var dd = d.getDate().toString();
	return this.logpath + '/' + yyyy + (mm[1] ? mm : '0'+mm[0]) + (dd[1] ? dd : '0'+dd[0]) + '.log';
  },

  /**
   * Log output message.
   *
   * @param  {String} levelStr
   * @param  {Array} args
   * @api private
   */

  log: function(levelStr, args) {

  	var d = new Date();

    if (exports[levelStr] <= this.level) {
    	var msg = fmt.apply(null, args);

		if (this.day != d.getDate()) {
			if (this.stream) {
				this.stream.write(this.getLogTime() + '--- End of Current log---' + '\n');
				this.stream.end();
			}
			this.day = d.getDate();
			this.logfile = this.getLogFile();
		}

		if (fs.existsSync(this.logfile) == false) {
			this.stream = fs.createWriteStream(this.logfile, {flags: 'a+', encoding: null, mode: 0666});
			this.stream.write(this.getLogTime() + '--- Start of Current log---' + '\n');
		}
		else {
			if (!this.stream) {
				this.stream = fs.createWriteStream(this.logfile, {flags: 'a+', encoding: null, mode: 0666});
			}
		}

		this.stream.write(
			this.getLogTime() 	+ 
			'-' + levelStr + '-'+
			' ' + msg			+
			'\n'
		);
    }
  },

  /**
   * Log emergency `msg`.
   *
   * @param  {String} msg
   * @api public
   */

  emergency: function(msg){
    this.log('EMG', arguments);
  },

  /**
   * Log alert `msg`.
   *
   * @param  {String} msg
   * @api public
   */

  alert: function(msg){
    this.log('ALT', arguments);
  },

  /**
   * Log critical `msg`.
   *
   * @param  {String} msg
   * @api public
   */

  critical: function(msg){
    this.log('CRI', arguments);
  },

  /**
   * Log error `msg`.
   *
   * @param  {String} msg
   * @api public
   */

  error: function(msg){
    this.log('ERR', arguments);
  },

  /**
   * Log warning `msg`.
   *
   * @param  {String} msg
   * @api public
   */

  warning: function(msg){
    this.log('WRN', arguments);
  },

  /**
   * Log notice `msg`.
   *
   * @param  {String} msg
   * @api public
   */

  notice: function(msg){
    this.log('NOT', arguments);
  },

  /**
   * Log info `msg`.
   *
   * @param  {String} msg
   * @api public
   */

  info: function(msg){
    this.log('INF', arguments);
  },

  /**
   * Log debug `msg`.
   *
   * @param  {String} msg
   * @api public
   */

  debug: function(msg){
    this.log('DBG', arguments);
  }
};

/**
 * Inherit from `EventEmitter`.
 */

Log.prototype.__proto__ = EventEmitter.prototype;
